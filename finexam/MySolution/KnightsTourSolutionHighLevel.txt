High-Level Description: In the Knight’s Tour problem, the state can be described by the knight’s current position and the set of visited squares. We seek a sequence of moves that visits all 64 squares exactly once. Warnsdorf’s rule is a heuristic that always moves the knight to the neighbor with the fewest onward moves available. I implement a Priority-Based Search that uses this heuristic:
State Representation: We keep track of the knight’s current position on the board and which squares have been visited so far (e.g. using a bit mask or boolean matrix of visited squares). We also maintain the path (sequence of moves) taken.
Initial State: The starting position of the knight (given as input). Initially, only that square is visited.
Goal State: All 64 squares have been visited (the path length is 64).
Successor Generation: From the current square, generate all possible knight moves (L-shaped moves) that stay on the board and lead to a square not yet visited. Each such move produces a new state with one additional square visited.
Priority Heuristic (Warnsdorf’s Rule): Each successor state is assigned a priority equal to the number of moves available from its position (the fewer the moves, the higher the priority for exploration). We use a min-heap (priority queue) to always expand the state with the smallest number of onward moves first. This means the search prefers paths that follow Warnsdorf’s rule, dramatically reducing backtracking.
Search Strategy: We perform a best-first search using the priority queue. Initially, the queue contains the start state. Repeatedly, the state with the lowest onward-move count is polled and expanded. If it’s a complete tour, we succeed. Otherwise, its children (next moves) are added to the queue according to their priority. This continues until a full tour is found or the queue is exhausted. In practice, Warnsdorf’s heuristic is usually sufficient to find a full knight’s tour without exploring many alternatives.
I define a class KnightTourState to encapsulate the state (current position, visited mask, move count, and path). The countNextMoves() method computes the heuristic (the number of available moves from the current position). The solver uses a priority queue (min-heap) ordered by this count. It expands states recursively in best-first order. If a tour is found, the path is printed.